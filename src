library(imager)
library(abind)
library(fitdistrplus)
library(wvtool)
library(ggplot2)

PositionToRowAndColAndLayer <- function(position_id){
  layer_position <- (position_id - 1) %/% PATCHES_PER_LAYER + 1
  row_position <- ((position_id - 1) %% PATCHES_PER_LAYER) %/% PATCH_COLUMNS +  1
  col_position <- ((position_id - 1) %% PATCHES_PER_LAYER) %% PATCH_COLUMNS + 1
  return(c(row_position, col_position, layer_position, 1))
}

ExtractBoundary <- function(patch_id, orientation, boundary_id) {
  patch_position <- PositionToRowAndColAndLayer(patch_id)
  layer_position <- patch_position[3]
  row_position <- patch_position[1]
  col_position <- patch_position[2]
  height_offset = PATCH_HEIGHT * (row_position - 1)
  rows = list(
    PATCH_HEIGHT:1 + height_offset,
    1 + height_offset,
    1:PATCH_HEIGHT + height_offset,
    PATCH_HEIGHT + height_offset
  )
  width_offset = PATCH_WIDTH * (col_position - 1)
  columns = list(
    1 + width_offset,
    1:PATCH_WIDTH + width_offset,
    PATCH_WIDTH + width_offset,
    PATCH_WIDTH:1 + width_offset
  )
  boundary_id_before_orientation = (boundary_id - orientation - 1) %% 4 + 1
  
  selected_rows <- rows[[boundary_id_before_orientation]]
  selected_columns <- columns[[boundary_id_before_orientation]]
  pixels <- IMAGE[selected_rows, selected_columns, layer_position,1]
  pixels <- as.vector(pixels)
  return(pixels)
}

ComputeResiduals <- function(position_row, position_column, position_layer, patches, orientations) {
  patch_id = patches[position_row, position_column, position_layer]
  orientation = orientations[position_row, position_column, position_layer]
  residual_list = list()
  # For neighbors on left, top, right and bottom.
  neighbor_row_offets = c(0,-1, 0, 1)
  neighbor_column_offets = c(-1, 0, 1, 0)
  neighbor_edge_id = c(3, 4, 1, 2)
  for (i in 1:4) {
    neighbor_row = position_row + neighbor_row_offets[i]
    neighbor_column = position_column + neighbor_column_offets[i]
    neighbor_patch_id = patches[neighbor_row, neighbor_column, position_layer]
    neighbor_orientation = orientations[neighbor_row, neighbor_column, position_layer]
    
    boundary = ExtractBoundary(patch_id, orientation, i)
    neighbor_boundary = ExtractBoundary(neighbor_patch_id, neighbor_orientation, neighbor_edge_id[i])
    residual_list[[i]] = boundary - rev(neighbor_boundary)
  }
  e = unlist(residual_list)
  return (e)
}

GeneratePatches <- function(patches_in_one_layer, layers) {
  patches <- array(0, dim = DIM)
  for (i in 1:layers) {
    patches[, , i] <- matrix((1+patches_in_one_layer*(i-1)):(patches_in_one_layer*i),
                             PATCH_ROWS, PATCH_COLUMNS, byrow = T)
  }
  return(patches)
}

SwapTwoPatches <- function(one_array, row1, col1, lay1, row2, col2, lay2){
  element_temp <- one_array[row1, col1, lay1]
  one_array[row1, col1, lay1] <- one_array[row2, col2, lay2]
  one_array[row2, col2, lay2] <- element_temp
  return(one_array)
}

ComputerAll32StatusResiduals <- function(selected_two_positions, patches, orientations){
  patches_1_position <- PositionToRowAndColAndLayer(selected_two_positions[1])
  patches_2_position <- PositionToRowAndColAndLayer(selected_two_positions[2])
  
  es = rep(0, 32)
  index = 1
  for (z in 1:2) {
    for (i in 1:4) {
      for (j in 1:4){
        residuals_1 = ComputeResiduals(patches_1_position[1], patches_1_position[2], patches_1_position[3], patches, orientations)
        residuals_1 <- residuals_1[is.finite(residuals_1)]
        residuals_2 = ComputeResiduals(patches_2_position[1], patches_2_position[2], patches_2_position[3], patches, orientations)
        residuals_2 <- residuals_2[is.finite(residuals_2)]
        es[index] <- sum(c(residuals_1, residuals_2)^2)
        index <- index + 1
        orientations[patches_2_position[1], patches_2_position[2], patches_2_position[3]] = (orientations[patches_2_position[1], patches_2_position[2], patches_2_position[3]]+1)%%4
      }
      orientations[patches_1_position[1], patches_1_position[2], patches_1_position[3]] = (orientations[patches_1_position[1], patches_1_position[2], patches_1_position[3]]+1)%%4
    }
    
    patches <- SwapTwoPatches(patches, patches_1_position[1], patches_1_position[2], patches_1_position[3], patches_2_position[1], patches_2_position[2], patches_2_position[3])
    orientations <- SwapTwoPatches(orientations, patches_1_position[1], patches_1_position[2], patches_1_position[3], patches_2_position[1], patches_2_position[2], patches_2_position[3])
  }
  return(es)
}

IndexToSwapRotations <- function(index){
  swap <- (index - 1) %/% 16 + 1
  rotation1 <- ((index - 1) %/% 4 ) %% 4 + 1
  rotation2 <- (index - 1) %% 4 + 1
  return(c(swap, rotation1, rotation2))
}

ComputerOneEdgeResiduals <- function(patches, orientations, edge_id){
    edge_id_in_one_layer <- (edge_id-1) %% (PATCHES_PER_LAYER*2) + 1
    layer_id <- (edge_id - 1) %/% (PATCHES_PER_LAYER*2) + 1
  if ((edge_id_in_one_layer <= PATCHES_PER_LAYER) && ((edge_id_in_one_layer %% PATCH_COLUMNS) !=0) ) {
    row_id <- (edge_id_in_one_layer - 1) %/% PATCH_COLUMNS +  1
    col_id <- (edge_id_in_one_layer - 1) %% PATCH_COLUMNS + 1
    row_id_right <- edge_id_in_one_layer %/% PATCH_COLUMNS +  1
    col_id_right <- edge_id_in_one_layer %% PATCH_COLUMNS + 1
    patch1 <- patches[row_id, col_id, layer_id]
    patch2 <- patches[row_id_right, col_id_right, layer_id]
    patch1_orientation <- orientations[row_id, col_id, layer_id]
    patch2_orientation <- orientations[row_id_right, col_id_right, layer_id]
    edge1 <- ExtractBoundary(patch1, patch1_orientation, 3)
    edge2 <- rev(ExtractBoundary(patch2, patch2_orientation, 1))
    e <- edge1 - edge2
  } else if ((edge_id_in_one_layer > PATCHES_PER_LAYER) && (edge_id_in_one_layer <= PATCH_COLUMNS*(PATCH_ROWS*2-1))) {
    row_id <- (edge_id_in_one_layer - PATCHES_PER_LAYER - 1) %/% PATCH_COLUMNS +  1
    col_id <- (edge_id_in_one_layer - PATCHES_PER_LAYER - 1) %% PATCH_COLUMNS + 1
    row_id_bottom <- (edge_id_in_one_layer -PATCHES_PER_LAYER - 1 + PATCH_COLUMNS) %/% PATCH_COLUMNS + 1
    col_id_bottom <- (edge_id_in_one_layer - PATCHES_PER_LAYER - 1 + PATCH_COLUMNS) %% PATCH_COLUMNS + 1
    patch3 <- patches[row_id, col_id, layer_id]
    patch4 <- patches[row_id_bottom, col_id_bottom, layer_id]
    patch3_orientation <- orientations[row_id, col_id, layer_id]
    patch4_orientation <- orientations[row_id_bottom, col_id_bottom, layer_id]
    edge3 <- ExtractBoundary(patch3, patch3_orientation, 4)
    edge4 <- rev(ExtractBoundary(patch4, patch4_orientation, 2))
    e <- edge3 - edge4
  } else e <- NULL
  return(e)
}

ComputerAllEdgeResiduals <- function(patches, orientations){
  z <- c()
  for (i in 1:(PATCHES_PER_LAYER*2*PATCH_LAYERS)) {
    e <- ComputerOneEdgeResiduals(patches = patches, orientations = orientations, edge_id = i)
    z <- c(z, e)
  }
  return(z)
}

OrientationRotation <- function(orientations, position1, position2, rotate1, rotate2) {
  a <- orientations
  a[position1[1], position1[2], position1[3]] <- (a[position1[1], position1[2], position1[3]] + (rotate1-1)%%4)%%4
  a[position2[1], position2[2], position2[3]] <- (a[position2[1], position2[2], position2[3]] + (rotate2-1)%%4)%%4
  return(a)
}

IndexToNewPatchesAndRotations <- function(selected_two_positions, selected_proposed_status, patches, orientations){
  patch_1_position <- PositionToRowAndColAndLayer(selected_two_positions[1])
  patch_2_position <- PositionToRowAndColAndLayer(selected_two_positions[2])
  id <- IndexToSwapRotations(selected_proposed_status)
  if (id[1] == 1) {
    patches <- patches
    orientations <- OrientationRotation(orientations, patch_1_position, patch_2_position, id[2], id[3])
  } else {
    patches <- SwapTwoPatches(patches, patch_1_position[1], patch_1_position[2], patch_1_position[3], patch_2_position[1], patch_2_position[2], patch_2_position[3])
    orientations <- SwapTwoPatches(orientations, patch_1_position[1], patch_1_position[2], patch_1_position[3], patch_2_position[1], patch_2_position[2], patch_2_position[3])
    orientations <- OrientationRotation(orientations, patch_1_position, patch_2_position, id[2], id[3])
  }
  return(list(patches = patches, orientations = orientations))
}

ShuffleArray <- function(my_array){
  a <- array(sample(as.vector(my_array)), dim = dim(my_array))
  return(a)
}

SquareAllEdgeResiduals <- function(patches, orientations){
  residuals <- list()
  residuals_temp <- list()
  LENGTH <- (PATCHES_PER_LAYER*2-PATCH_ROWS-PATCH_COLUMNS)*PATCH_HEIGHT
  for (i in 1:PATCH_LAYERS) {
    residuals_temp[[i]] <- (ComputerAllEdgeResiduals(patches, orientations)[(LENGTH*(i-1)+1):(LENGTH*i)])^2
    residuals[[i]] <- residuals_temp[[i]][is.finite(residuals_temp[[i]])]
    residuals[[i]][residuals[[i]]==0] <- 1e-10
  }
  return(residuals)
}

ParameterEstimation <- function(residuals) {
  parameter <- list()
  for (i in 1:PATCH_LAYERS) {
    parameter[[i]] <- tryCatch({fitdist(residuals[[i]], "gamma", method = "mle")$estimate},
                         error = function(error_type) {return(c())})
  }
  return(parameter)
}

SelectTwoPositions <- function(PATCH_ROWS, PATCH_COLUMNS, PATCH_LAYERS){
  array_of_interest <- GeneratePatches(PATCHES_PER_LAYER, PATCH_LAYERS)
  inside_array <- array_of_interest[2:(PATCH_ROWS-1), 2:(PATCH_COLUMNS-1), ]
  patches_of_interest <- as.vector(inside_array)
  two_positions <- sample(patches_of_interest, 2, replace = FALSE)
  return(two_positions)
}

PatchesToImage <- function(patches, orientations){
  output_image <- initial.image
  for (k in 1:PATCH_LAYERS) {
    for (i  in 2:(PATCH_ROWS-1)) {
      for (j in 2:(PATCH_COLUMNS-1)) {
        id <- patches[i,j,k]
        patch_position <- PositionToRowAndColAndLayer(id)
        patch_row <- patch_position[1]
        patch_col <- patch_position[2]
        patch_lay <- patch_position[3]
        source_rows <- ((patch_row-1)*PATCH_HEIGHT+1) : (patch_row*PATCH_HEIGHT)
        source_cols <- ((patch_col-1)*PATCH_WIDTH+1) : (patch_col*PATCH_WIDTH)
        patch <- as.cimg(initial.image[source_cols, source_rows, patch_lay,1])
        degree <- orientations[i,j,k]*90
        patch <- imrotate(patch, degree)
        dest_rows <- ((i-1)*PATCH_HEIGHT+1) : (i*PATCH_HEIGHT)
        dest_cols <- ((j-1)*PATCH_WIDTH+1) : (j*PATCH_WIDTH)
        dest_lays <- k
        output_image[dest_cols, dest_rows, dest_lays,1] <- patch[, , 1,]
      }
    }
  }
  return(output_image)
}

PlotCounterTrend <- function(iterations_at_changes, iterations_between_changes, residuals_between_changes){
  iterations_at_changes <- unlist(iterations_at_changes)
  iterations_between_changes <- unlist(iterations_between_changes)
  residuals_between_changes <- unlist(residuals_between_changes)
  df <- data.frame(
    iterations_at_changes,
    iterations_between_changes,
    residuals_between_changes
  )
  colnames(df) <- c("Sequence", "unchanged_runs", "whole_residual")
  p <- ggplot(df) + 
    geom_line(mapping = aes(x = Sequence, y = whole_residual), color = "blue") +
    geom_line(mapping = aes(x = Sequence, y = unchanged_runs), color = "green") +
    geom_hline(yintercept=true_all_residual, linetype="dashed", color = "red", size=2) +
    ggtitle("Find the number of runs for convergence")
  return(p)
}

PlotImage <- function (image) {
	df <- as.data.frame(true.image1)
	p <- ggplot(df, aes(x, y)) + geom_raster(aes(fill = value)) + scale_x_continuous(expand=c(0,0)) + scale_y_continuous(expand=c(0,0),trans=scales::reverse_trans()) + scale_fill_gradient(low="black",high="white")
	return(p)
}

PATCH_ROWS = 15
PATCH_COLUMNS = 10
PATCH_LAYERS = 2
PATCHES_PER_LAYER = PATCH_ROWS * PATCH_COLUMNS
PATCH_HEIGHT = PATCH_WIDTH = 50
set.seed(12345)


true.image1 <- load.image
dim(true.image1)

true.image2 <- load.image
dim(true.image2)

IMAGE <- array(NA, dim = c(PATCH_COLUMNS*PATCH_HEIGHT, PATCH_ROWS*PATCH_WIDTH, PATCH_LAYERS, 1))
IMAGE[,,1,] <- true.image1[, , 1, ]
IMAGE[,,2,] <- true.image2[, , 1, ]
initial.image <- IMAGE
IMAGE <- aperm(IMAGE, c(2, 1, 3, 4))

DIM = c(PATCH_ROWS, PATCH_COLUMNS, PATCH_LAYERS)
true_patches <- GeneratePatches(PATCHES_PER_LAYER, PATCH_LAYERS)
true_patches
patches <- true_patches
rows <- 2:(PATCH_ROWS-1)
columns <- 2:(PATCH_COLUMNS-1)
patches[rows, columns,] <- ShuffleArray(patches[rows, columns,])
patches

true_orientations <- array(0, dim = DIM)
orientations <- sample(0:3, (PATCH_ROWS -2)*(PATCH_COLUMNS-2)*PATCH_LAYERS, replace=T)
orientations <- array(orientations, dim=c(PATCH_ROWS-2, PATCH_COLUMNS-2, PATCH_LAYERS))
orientations_expanded <- true_orientations
orientations_expanded[rows, columns,] <- orientations
orientations <- orientations_expanded
orientations

true_all_residual <- sum(Reduce(`+`, SquareAllEdgeResiduals(true_patches, true_orientations)))

initial_patches <- patches
initial_orientations <- orientations
a1 <- PatchesToImage(initial_patches, initial_orientations)
par(mfrow=c(1, PATCH_LAYERS))
for (k in 1:PATCH_LAYERS) {
  plot(as.cimg(a1[,,k,]))
}


# initialization
i <- 1
iteration_counter <- 0
iterations_at_changes <- list()
iterations_between_changes <- list()
residuals_between_changes <- list()
change_index <- 1
plot_to_find_count <- list()
patches_list <- list()
orientations_list <- list()
residuals_list <- list()
record_period <- 20000
print_period <- 1
record_counter <- 0

while(TRUE){
  if(i%%print_period==0) {print(i)}
  if((i %% record_period) == 0){
    record_counter <- record_counter + 1
    print(patches)
    print(orientations)
    patches_list[[record_counter]] <- patches
    orientations_list[[record_counter]] <- orientations
    residuals_list[[record_counter]] <- sum(Reduce(`+`, current_all_residuals))
    
    
    z <- as.character(i)
    a1 <- PatchesToImage(initial_patches, initial_orientations)
    a2 <- PatchesToImage(patches, orientations)
    par(mfrow=c(3, PATCH_LAYERS))
    plot(true.image1, xlim = c(0, 600), ylim = c(800, 0))
    plot(true.image2, xlim = c(0, 600), ylim = c(800, 0))
    for (k in 1:PATCH_LAYERS) {
      plot(as.cimg(a1[,,k,]), xlim = c(0, 600), ylim = c(800, 0))
    }
     for (k in 1:PATCH_LAYERS) {
      plot(as.cimg(a2[,,k,]), xlim = c(0, 600), ylim = c(800, 0))
    }
    dev.off()
  }
  
  i <- i + 1


  selected_two_positions <- SelectTwoPositions(PATCH_ROWS, PATCH_COLUMNS, PATCH_LAYERS)
  selected_proposed_status <- sample(2:32, 1)

  result <- IndexToNewPatchesAndRotations(
    selected_two_positions, selected_proposed_status, patches, orientations)
  new_patches <- result$patches
  new_orientations <- result$orientations
  
  current_all_residuals <- SquareAllEdgeResiduals(patches, orientations)
  parameter1 <- ParameterEstimation(current_all_residuals)
  proposed_all_residuals <- SquareAllEdgeResiduals(new_patches, new_orientations)
  parameter2 <- ParameterEstimation(proposed_all_residuals)
  
  es <- ComputerAll32StatusResiduals(selected_two_positions, patches, orientations)
  transition_prob_current_to_proposed <- es[selected_proposed_status]^(-1) / sum(es[-1]^(-1))
  transition_prob_proposed_to_current <- es[1]^(-1) / sum(es[-selected_proposed_status]^(-1))
  transition_ratio <- transition_prob_proposed_to_current/transition_prob_current_to_proposed
  
  ll_proposed <- list()
  ll_current <- list()
  if ((length(unlist(parameter2)) != (2*PATCH_LAYERS)) | (is.na(transition_ratio) == T)) {prob_final <- 0
  } else if (length(unlist(parameter1)) != (2*PATCH_LAYERS)) {prob_final <- Inf
  } else{ 
    for (z in 1:PATCH_LAYERS) {
      ll_proposed[[z]] <- sum(dgamma(proposed_all_residuals[[z]],parameter2[[z]][1],scale = 1 / (parameter2[[z]][2]), log = TRUE))
      ll_current[[z]] <- sum(dgamma(current_all_residuals[[z]], parameter1[[1]][1],scale = 1 / (parameter1[[1]][2]), log = TRUE))
    }
    ll_ratio <- exp(sum(unlist(ll_proposed)) - sum(unlist(ll_current)))
    prob_final <- transition_ratio * ll_ratio
  }
  
  if (min(1, prob_final) > runif(1)) {
    patches <- new_patches
    orientations <- new_orientations
  }
  
  if (prob_final >= 0.55){
    iterations_at_changes[[change_index]] <- i
    iterations_between_changes[[change_index]] <- iteration_counter
    residuals_between_changes[[change_index]] <- sum(Reduce(`+`, current_all_residuals))
    change_index <- change_index + 1
    iteration_counter <- 0
  } else {
    iteration_counter <- iteration_counter + 1
  }
  
  if (iteration_counter > 150000) {
    break
  }
}





















